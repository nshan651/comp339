#include <main.hh>

using namespace std;

/* Decoded decoder(Cipher cipher, istream &input) */
CipherMap decoder(const Cipher &cipher) 
/** Create a grouping of decoded sentences and their shifts */
{
    /* Populate mapping */
    CipherMap encoded;

    map<string, int> dictionary = parse_dict(cipher);
    string nline;
    while (getline(cipher.input, nline)) {
        /* Skip blank, strip metadata */
        if (nline == "")
            continue;
        string line = strip_metadata(nline);

        vector<string> words = split_line(line, cipher.min_len);
        int shift = decode(words, dictionary);
        /* Output header if output is cout */
        if (cipher.std_out == "")
            cout << "\nSHIFT => " << shift << " WORDS => ";
        vector<string> collect = collect_words(words, 
                                        shift_left,
                                        cipher.output,
                                        shift);
        encoded[collect] = shift;
    }
    return encoded;
}

#ifdef DECODER
int main(int argc, char **argv)
/** 
The decoder does the following:
    - Reads one line of input at a time.
    - Parses the line of input into words. A word is any continuous sequence of letters from the alphabet.
    - Characters not in a word should be preserved to the fullest extent possible (e.g. whitespace and any punctuation.)
    - Try all shift values with your Caesar cipher to see if all words in a line of input can be decoded. You will know if they can be decoded by looking up the words in the dictionary. Thus the decoder must be able to load the dictionary as well.
    - Output the shift value on success. If for any reason an input line cannot be decoded, output a -1. This would never happen if your encoder and decoder are both working, but it is entirely possible a file generated by someone else could present problems.
    - You can also write the decoder to succeed if most of the words are decoded. This could be an additional command line option, e.g. --threshold=percentage.
*/
{
    Cipher cipher = build_cipher(argc, argv);

    CipherMap cmap = decoder(cipher);

    return 0;
}
#endif
