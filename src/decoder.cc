#include <main.hh>

using namespace std;

int decoder(vector<string> &words, map<string, int> &dictionary)
/** 
name output text (of shift values) to filename (if absent, write to standard output)
The decoder does the following:
    - Reads one line of input at a time.
    - Parses the line of input into words. A word is any continuous sequence of letters from the alphabet.
    - Characters not in a word should be preserved to the fullest extent possible (e.g. whitespace and any punctuation.)
    - Try all shift values with your Caesar cipher to see if all words in a line of input can be decoded. You will know if they can be decoded by looking up the words in the dictionary. Thus the decoder must be able to load the dictionary as well.
    - Output the shift value on success. If for any reason an input line cannot be decoded, output a -1. This would never happen if your encoder and decoder are both working, but it is entirely possible a file generated by someone else could present problems.
    - You can also write the decoder to succeed if most of the words are decoded. This could be an additional command line option, e.g. --threshold=percentage.
*/
{
    /* The threshold for the number of matching words in a shift */
    int threshold = words.size();
    int shift = 0;

    for (shift = 1; shift <= ALPHABET_SIZE; shift++) {
        int matches = 0;
        for (string &word : words) {
            string candidate;
            for (size_t i = 0; i < word.length(); i++) {
                char c = word[i];
                if(c >= 'A' && c <= 'Z') {
                    c -= shift;
                    if(c < 'A')
                       c = c + 'Z' - 'A' + 1;
                    candidate += c;
                }
            }
            if (dictionary.count(candidate) > 0) {
                matches++;
                //cout << candidate << "\n";
                if (matches >= threshold)
                    return shift;
            }
        }
    }
    return shift;
}
